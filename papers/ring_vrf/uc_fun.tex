% !TEX root = crypto.tex

\begin{figure}
	\begin{tcolorbox}[left=2pt,right=2pt]
	\small
		{  $ \fgvrf $ runs a PPT algorithms  $\Gen_{sign} $ during the execution and is parametrized with  sets $ \setsym{S}_{eval} $ and $ \setsym{S}_W $ where $ \setsym{S}_{eval} $ and $ \setsym{S}_W $ generated by a set up function $ \mathsf{Setup}(1^\secparam) $.
			%We need to select W randomly because we need it to be unique
	
		\textbf{[Key Generation.]} Upon receiving a message $(\oramsg{keygen}, \sid)$ from  $\user_i$, send $(\oramsg{keygen}, \sid, \user_i)$ to the simulator $\simulator$.
		Upon receiving a message $(\oramsg{verificationkey}, \allowbreak \sid, \sk,\pk)$ from $\simulator$, verify that $\sk $ or $\pk$ has not been recorded before for $ \sid $ in $ \vklist $. If it is the case, store  the value $\sk,\pk$ in the table $\vklist$ under $\user_i$ and return $(\oramsg{verificationkey}, \sid, \pk)$ to $ \user_i$.
			
			%\textbf{[Malicious Key Generation.]} upon receiving a message $(\oramsg{keygen}, \sid, \pk)$ from $\simulator$, verify that $\pk$ was not yet recorded, and if so record in the table $\vklist$ the value $\pk$ under $\simulator$. Else, ignore the message.
			
			%\item[Honest Ring VRF Evaluation.] upon receiving a message $(\oramsg{eval}, \sid, \ring, \pk_i, m)$ from $\user_i$, verify that 
			%$\pk_i \in \ring$ 
			%and  
			%there exists $ \pk_i $ in $\vklist $ associated with $ \user_i $. If that was not the case, just ignore the request.
			%If there exists no $ W $ such that $ \anonymouskeymap[W] = (m, \ring, \pk_i) $, let $ W \leftsample \bin^\secparam $ and  $y \leftsample \setsym{S}_{eval}$. Then, set $ \evaluationslist[m, W] = y$ and $ \anonymouskeymap[W] = (m, \ring,\pk_i) $.
			%Return $(\oramsg{evaluated}, \sid, \ring, m, W, y)$ to $ \user_i $.
			%The functionality does not check whether the evaluater's public key is in the ring because here we consider m, \ring as an input of the evaluation which is evaluated by a party who is not neccesarily in the ring. 
			\textbf{[Honest Ring VRF Signature and Evaluation.]} Upon receiving a message $(\oramsg{sign}, \sid, \ring, \pk_i,\aux, \msg)$ from $\user_i$, verify that $\pk_i \in \ring$ and that there exists a public key $\pk_i$ associated to $\user_i$ in $ \vklist $. If it is not the case, just ignore the request. 	
			If there exists no $ W' $ such that $ \anonymouskeymap[\msg,W'] =  \pk_i $, let $ W \leftsample \setsym{S}_W $ and let $\Out \leftsample \setsym{S}_{eval}$. Set $ \anonymouskeymap[\msg,W] = \pk_i $ and set $ \evaluationslist[\msg, W] = \Out$.
			In any case (except ignoring), obtain $ W, \Out$ where $ \anonymouskeymap[\msg,W] =\pk_i $, $ \evaluationslist[\msg, W] = \Out$ and  $ (\sk, \pk) $ is in $\vklist $. Then run  $ \Gen_{sign}(\ring,\sk,\pk,\aux,\msg) \rightarrow \sigma $.
			%Verify that $ [\msg,\aux, W,\ring, \sigma, 0] $ is not recorded. If it is recorded, abort. Otherwise,
			Let $ \sigma = (\sigma,W)$ and record $ [\msg,\aux, W, \ring,\sigma, 1] $. Return $(\oramsg{signature}, \sid, \ring,W,\aux,\msg, \Out, \sigma)$ to $\user_i$.
			
			\textbf{[Malicious Ring VRF Evaluation.]}  Upon receiving a message $(\oramsg{eval}, \allowbreak \sid, \allowbreak \pk_i, \allowbreak W, \msg)$ from $\sim$, if $ \pk_i $ is recorded under an honest party's identity or if there exists $ W'\neq W $ where $ \anonymouskeymap[\msg,W'] = \pk_i $, ignore the request.
			Otherwise, record in the table $\vklist$ the value $(\perp,\pk_i)$ under $\simulator$ if $ (.,\pk_i) $ is not in $ \vklist $.
			If  $\anonymouskeymap[\msg,W]  $ is not defined before, set $ \anonymouskeymap[\msg,W] = \pk_i $ and let   $\Out \leftsample \setsym{S}_{eval}$ and set $ \evaluationslist[\msg, W] = \Out$.
			In any case (except ignoring), obtain $ \Out = \evaluationslist[\msg, W] $ and return $(\oramsg{evaluated}, \sid,  \msg, \pk_i,W, \Out)$ to $ \user_i $.
			
			\textbf{[Corruption:] } 
			Upon receiving $ (\oramsg{corrupt}, \sid, \user_i) $ from $ \simulator $, remove $ (x_i,\pk_i) $ from $ \vklist[\user_i] $ and store them to $ \vklist $ under $ \sim $. Return $ (\oramsg{corrupted}, \sid,\user_i) $.
			
			\textbf{[Malicious Requests of  Signatures.]} Upon receiving a message $ (\oramsg{signs}, \sid, \allowbreak W, \aux,\msg) $ from $ \simulator $, obtain all existing valid signatures $ \sigma $ such that $ [\msg, \aux,W,.,\sigma, 1] $ is recorded and add them in a list $ \lst_{\sigma} $. 	Return $ (\oramsg{signs}, \sid, W,\aux,\msg, \lst_{\sigma})  $ to $ \simulator $.
			
			\textbf{[Ring VRF Verification.]} Upon receiving a message $(\oramsg{verify}, \sid, \ring,W, \aux, \msg, \sigma)$ from a party, do the following: 
			% \begin{list}[label={{C}}{{\arabic*}}, start = 1]
				% https://texblog.net/help/latex/ltx-260.html
				
				\begin{list}{\hspace*{1pt} C\arabic{FunCond}}{\usecounter{FunCond}\setlength\leftmargin{0.15in}}
					\item If there exists a record $ [\msg,\aux,W,\ring,\sigma, b'] $, set $ b = b' $. 
					%(This condition guarantees the completeness and consistency.)
					%					\item Else if $ \pk  $ is an honest verification key where $ \anonymouskeymap[W] = (.,., \pk) $ and there exists no record $ [m, \ring, W, \sigma', 1] $ for any $ \sigma' $, then let $ b= 0  $.
					%					(This condition guarantees unforgeability meaning that if an honest party never signs a message $ m $ for a ring $ \ring $, then the verification fails.)\label{cond-main:forgery}
					
					%\item Else if there exists a record  such as $ [m,W,\ring,\sigma, b'] $, set $ b = b' $. (This condition guarantees consistency meaning that all identical verification requests will output the same $ b $) 
					\label{cond:consistency}
					\item Else if $ \anonymouskeymap[\msg,W]  $ is an honest verification key and  there exists a record $ [\msg,\aux, W, \ring, \sigma', 1] $ for any $ \sigma' $, then let $ b=1 $ and record $ [\msg,\aux, W,\ring,\sigma, 1] $. 
					%(This condition guarantees that if $ \msg $ is signed by an honest party for the ring $ \ring $ at some point, then the signature is $ \sigma' \neq \sigma $ which is generated by the adversary is valid) 
					\label{cond:differentsignature}
					
					\item \label{cond:malicioussignature}Else relay the message $(\oramsg{verify}, \sid, \ring,W,\aux, \msg, \sigma)$ to $ \simulator $ and receive back the message $(\oramsg{verified}, \sid, \ring,W,\aux, \msg, \sigma, b_{\simulator}, \pk_\simulator)$.  Then check the following:
					
					\begin{enumerate}
						\item If   $ \pk_\simulator $ is an honest verification key, set $ b = 0 $. 
						% (This condition guarantees unforgeability meaning that if an honest party never signs a message $ \msg$ for a ring $ \ring $)
						\label{cond:forgery}
						
						\item Else if $ W \notin \anonymouskeylist[\msg,\ring] $ and $ |\anonymouskeylist[\msg, \ring]| \geq |\ring_{mal}| $ where $ \ring_{mal} $ is a set of malicious keys in $ \ring $, set $ b = 0 $.
						%(This condition guarantees  uniqueness meaning that the number of verifying outputs that $ \sim $ can generate for $ \msg, \ring $ is at most the  number of malicious keys in $ \ring $.)
						\label{cond:uniqueness}.
						%\item \label{cond-main:forgerymalicious}Else if there exists $ \anonymouskeymap[W] = (m', \ring',.)  $ where $ (m', \ring') \neq (m, \ring) $ or $ \counter[m, \ring] > |\ring_m| $ where $ \ring_m $ is a set of keys in $ \ring $ which are not honest or $ b_{\simulator} = 0 $ or $ \pk_\simulator $ belongs to an honest party, set $ b = 0 $ and record $ [m, \ring,W,\sigma, 0] $. (This condition guarantees that if $ W $ is an anonymous key of a different message and ring or the number of anonymous keys of malicious parties in $ \ring $ is more than their number or     $ \simulator $ does not verify $ \sigma $, then the verification fails.)
						
						\item Else if there exists $ W' \neq W $ where  $ \anonymouskeymap[\msg,W'] = \pk_\simulator $, set $ b = 0 $. \label{cond:differentWforsamepk} 
						%(This condition guarantees that there exists a unique anonymous key for each $ (\msg, \pk_\simulator) $)
						\item Else set $ b = b_\sim$. \label{cond:simulatorbit}
					\end{enumerate}		
					
				\end{list}
				In the end,  record $ [\msg,\aux,W,\ring,\sigma, 0] $ if it is not stored. If $ b = 0 $, let $\Out= \perp $. Otherwise,   do the following:
				\begin{itemize}
					\item If $ W \notin \anonymouskeylist[\msg,\ring] $, add $ W $ to $ \anonymouskeylist[\msg,\ring]  $.
					%\item if $ \pk_\simulator $ is not recorded, record it in $ \vklist $ under $ \simulator $.
					\item If $ \evaluationslist[\msg,W] $ is not defined, sample $ y \leftsample \setsym{S}_{eval}$. Then, set $ \anonymouskeymap[\msg,W]  = \pk_\simulator$ and $ \evaluationslist[\msg, W] = \Out$.
					\item Otherwise, set $ \Out = \evaluationslist[\msg, W]$. 	
				\end{itemize}
				Finally, output $(\oramsg{verified}, \sid, \ring,W, \aux,\msg, \sigma, \Out, b)$ to the party.
				
				
				\textbf{[Corruption:]} 
				Upon receiving $ (\oramsg{corrupt}, \sid, \user_i) $ from $ \simulator $, remove $ (\sk_i,\pk_i) $ from $ \vklist[\user_i] $ and store them to $ \vklist $ under $ \sim $. Return $ (\oramsg{corrupted}, \sid,\user_i) $.
			}
		\end{tcolorbox}
		\caption{Functionality $\fgvrf$.\label{f:gvrf}}
	\end{figure}
	
	
