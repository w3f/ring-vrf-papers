% !TEX root = main.tex

%\input{uc_simulation}
\section{Security of Our Ring VRF Constructions}

\subsection{Security of Our First Ring VRF Construction}
\label{ap:firstprotocolproof}
We describe the simulation in Section \ref{sec:pedersen_vrf}. We now show the indistinguishability of our simulation.

We begin by proving Lemma \ref{lem:honestoutput}.

\begin{proof}
	The evaluation outputs of the ring signatures in the ideal world are identical to the real-world protocol because  the outputs are randomly selected by $ \fgvrf $ as the random oracle $ \hash $ in the real protocol. The only difference is the ring signatures of honest parties (See Algorithm \ref{alg:gensign}) since the pre-output $ W $ and $ \pi_1 $ are generated differently in Algorithm \ref{alg:gensign} than $ \rVRF.\Sign $. The distribution of $ \pi_{eval} = (c,s_1, s_2) $ and $ \compk $ generated by Algorithm \ref{alg:gensign} and the distribution of $ \pi_{eval} = (c,s_1, s_2) $ and $ \compk $ generated by $ \rVRF.\Sign $ are from the uniform distribution, so they are indistinguishable. What remains to show is that the anonymous key $ W $ selected randomly from $ \grE $ and pre-output $	 W $ generated by $ \rVRF.\Sign $ are indistinguishable given $ \pk  $. 
	
	\textbf{Case 1 ($ \pk \leftarrow \mathsf{Com}.\mathsf{Commit}(x,r)$):} Since $ \pk$ is a perfectly hiding commitment, then  $ \pk $ is uniformly random and independent from $ x $. Therefore,  the anonymous key $ W $ selected randomly from $ \grE $ and pre-output $ W = x \genG $ generated by $ \rVRF.\Sign $ are indistinguishable given $ \pk  $.
	
	\textbf{Case 2 ($ \pk = x \genG$):} In this case, $ \pk $ is not independent from the secret key. Thus, in order to prove indistinguishability, we rely on the assumption that the DDH problem  is hard.  We show that if there exists a distinguisher $ \mathcal{D} $ that distinguishes honest signatures in the ideal world and honest signatures in the real protocol, then we can construct an adversary $ \bdv $ which breaks the DDH problem. 
	We demonstrate this via the following hybrid argument.
	We define hybrid simulations $ H_{i} $ where  the signatures of first $ i $ honest parties are computed as described in $ \rVRF.\Sign $ and the rest are computed as in $ \fgvrf $. Without loss of generality, $ \user_1, \user_2, \ldots, \user_{n_h} $ are the honest parties. Thus, $ H_0 $ is equivalent to the honest signatures generated in the ideal world  and $ H_{n_h}  $ is equivalent to  honest signatures in the real world.  We construct an adversary $ \bdv $ that breaks the DDH problem given that there exists an adversary $ \mathcal{D} $ that distinguishes hybrid games $ H_i $ and $ H_{i + 1} $ for $ 0 \leq i < n_h $. $\bdv $ receives the DDH challenges $ X,Y, Z \in \GG $ from the DDH game and simulates the game against $ \mathcal{D} $ as follows. 
	$ \bdv $ runs a simulated copy of $ \env $ and starts to simulate $ \fgvrf $ and $ \simulator $ for $ \env $. For this, it first runs the simulated copy of $ \adv $ as $ \simulator $ does. $  \bdv $ publishes $ \GG, \genG = Y, \genB $ as parameters of the ring VRF protocol. $\bdv $ generates the public key of all  honest parties' keys as usual by running $ \rVRF.\KeyGen$ as $ \simulator $ does, except for party $ \user_{i+1} $. It lets the public key of $ \user_{i + 1} $ be $ X $.
	
	%			\begin{algorithm}
		%				
		%				\caption{$\gen^{ind}_{sign}(\ring,\openring,W,\{X,\pk\},\aux,\msg)$}
		%				\label{alg:gensignind}	 	
		%				\begin{algorithmic}[1]
			%					\State $ \compk \leftsample \grE$
			%					\State $ \pi_{eval}  \leftarrow \NIZK_{\rcom}.\Simulate(\compk,W,\hashG(\msg)) $
			%					%\State $ \pi_{eval} \leftarrow \NIZK.\mathsf{Simulate}(\rcom, (G, \genB,\GG,\compk,W,\In)) $
			%					%\State \textbf{send} $(\oramsg{learn\_\tau},\sid)  $ to $ \gcrs $
			%					%\State \textbf{receive} $(\oramsg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
			%					\If{$ \pk = \OpenRing(\comring,\openring) $}
			%					\State $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\Simulate((\comring, \compk)) $ 
			%					\State\Return$ \sigma = (\pi_{eval},\pi_{ring},\compk,\comring,W) $
			%					\EndIf
			%				\end{algorithmic}
		%				
		%			\end{algorithm}
	
	
	While simulating $ \fgvrf $, $\bdv $ simulates the ring signatures of the first $ i $ parties by running $ \rVRF.\Sign $ and the parties $ \user_{i+2}, \ldots, \user_{n_h} $ by running Algorithm \ref{alg:gensign} where $ W $ is selected randomly. The simulation of $ \user_{i + 1} $ is different.  Whenever $ \user_{i+1} $ needs to sign an input $ \msg$ and message $ \aux $, it obtains $ \In = \hashG(m) = hY $ from the oracle $ \mathtt{H}_p $ and lets $ W = hZ $. Then it sets $ \compk = X + \openpk\genB $ and  $ \pieval \leftarrow \NIZK_{\rcom}. \Simulate(\compk,W,\msg) $ and  $ \pi_{ring} \leftarrow \NIZK_{\rsnark}. \Simulate(\compk, \comring) $ by inputting $ \aux $ in the random oracle $ \hash $.  Note that if $ (X,Y,Z)$ is a DH triple (i.e., $  \mathsf{DH}(X,Y,Z) \rightarrow 1 $), $ \user_{i+1} $ is simulated as in in our construction because $ W = \sk \genG$ in this case. Otherwise, $ \user_{i+1} $ is simulated as in the ideal world because $ W $ is random. So, if $  \mathsf{DH}(X,Y,Z)  \rightarrow 1$, $\simulator $ simulates $ H_{i+1} $. Otherwise, it simulates $ H_{i} $. In the end of the simulation, if $ \mathcal{D} $ outputs $ i $, $\simulator $ outputs $ 0 $, meaning $  \mathsf{DH}(X,Y,Z) \rightarrow 0$. Otherwise, it outputs $ i + 1 $. The success probability of $\simulator $ is equal to the success probability of $\mathcal{D} $, which distinguishes $ H_i $ and $ H_{i +1} $. Since the DDH problem is hard, $\simulator $ has negligible advantage in the DDH game. Thus, $ \mathcal{D} $ also has negligible advantage. Hence, from the hybrid argument, we can conclude that $ H_0    $, which corresponds the output of honest parties in  the ring VRF protocol, and $ H_q  $, which corresponds to  the output of honest parties in ideal world, are indistinguishable.
	
	This concludes the proof of showing the outputs of honest parties in the ideal world are indistinguishable from the outputs of the honest parties in the real protocol.
\end{proof}	

Next we show that the simulation executed by $ \simulator $ against $ \adv $ is indistinguishable from the real protocol execution.

We now prove Lemma \ref{lem:simulation-ind}.


\begin{proof}
	The  simulation against the real-world adversary $ \adv $ is identical to the real protocol except the cases where $ \simulator $ aborts. \abort-1 cannot happen, as explained during the simulation.  \abort-2 happens if $ \Gen_{sign} $ generates the same $ \compk $ for two different signatures. This happens if $ \fgvrf $  selects the same $ \compk $ for two different honest signatures, which occurs with negligible probability.
	Now, we must handle the abort case (\abort-3) during the verification.
	For this, we show that if there exists an adversary $ \adv $ which makes $ \simulator $ abort during the simulation, then we can construct another adversary $ \bdv $ which breaks either the CDH problem or the binding property of $ \mathsf{Com}$.
	
	Consider a CDH game in a prime $ p $-order group  $ \grE $ with the challenges $ \genG,U, V \in \grE$. The CDH challenges are given to the simulator $ \bdv $. Then $ \bdv $ runs a simulated copy of $ \env $ and starts to simulate $ \fgvrf $ and $ \simulator $ for $ \env $. For this, it first runs the simulated copy of $ \adv $ as $ \simulator $ does. $ \bdv $ provides $ (\grE, p, \genG , \genB) $ as public parameters for the ring VRF protocol to $ \adv $.
	
	Whenever $ \bdv $ needs to generate a ring signature on input $ \msg $ and message $ \aux $ on behalf of an honest party, it behaves exactly as $ \fgvrf $, except it runs   Algorithm \ref{alg:gensignbdv} to generate the signature. 
	%			
	%			\begin{algorithm}
		%				\caption{$\gen_{W}(X, m)$}
		%				\label{alg:genWbdv}	 	
		%				\begin{algorithmic}[1]
			%					\If{$ DB_W[m, X] = \perp $}
			%					\State $ W \leftsample \GG$
			%					\State $ DB_W[m, X] := W $
			%				%	\State \textbf{add} $ W $ to list $ \anonymouskeylist[m,\ring] $
			%					\EndIf
			%					\State \textbf{return} $ DB_W[m, X] $
			%				\end{algorithmic}
		%			\end{algorithm}
	
	%TODO: Check consistency with the simulator defined in Prelim
	\begin{algorithm}
		\caption{$\gen_{sign}(\ring,W,\pk,\aux,\msg)$}
		\label{alg:gensignbdv}	 	
		\begin{algorithmic}[1]
			%					\State $ c,s_1, s_2 \leftsample \FF_p $
			%					\State $ \pi_{eval}  \leftarrow (c,s_1, s_2)$
			%\State $ \openpk \leftsample \FF_p $
			\State $ \compk\leftsample \grE$
			\State $ \pieval \leftarrow \NIZK_{\mathcal{R}_{eval}}.\Simulate(\compk, W,\msg) $
			\State $ \comring, \openring \leftarrow \rVRF.\CommitRing(\ring) $
			\State $ \piring \leftarrow \NIZK_{\rsnark}.\Simulate(\comring, \compk) $ 
			%					\State $ R' = s\genG +\delta K + c\compk$
			%					\State $ R_m = s\hashG(m) + c W $
			%					\State $ \aux' = \tmpaux $
			%					\State $ \mathtt{H_p}[\aux',m, \compk,W,R',R'_m] = c$						
			\State\Return$ \sigma = (\compk,\piring, \comring, \pieval) $
		\end{algorithmic}
		
	\end{algorithm}
	
	
	Clearly, the ring signature of an honest party output by $ \simulator $ (recall that $ \fgvrf$ generates it by Algorithm \ref{alg:gensign}) and the ring signature generated by $ \bdv $ are indistinguishable. Note that $ \bdv $ does not need to set $ \hash_p $ anymore as $ \simulator $ so that $ \pieval $ verifies because $ \Gen_{sign} $ in Algorithm \ref{alg:gensignbdv} does it while simulating the proof for $ \rel_{eval} $. Therefore, the simulation of $ \hash_p $ is simulated as a usual random oracle by $ \bdv $.
	
	In order to generate the public keys of honest parties, $ \bdv $ picks a random $ r_x\in \FF_p $ and sets $ X =r_xV$. If $ \rVRF.\KeyGen $  generates a public key as $ \pk = \sk \genG $, it lets $ \pk $ be $ X $; otherwise, it picks a random public key $ \pk $ .
	Note that $ \bdv$  never needs to know the secret key of honest parties to simulate them since $ \bdv $ selects anonymous keys randomly  and generates the ring signatures  without the secret keys. Since the public key generated by $ \rVRF.\KeyGen $ is random and independent from the secret key, $ \bdv $'s key generation is indistinguishable from $ \rVRF.\KeyGen $, if $\rVRF.\KeyGen $  generates a public key as a commitment.
	
	
	$ \bdv $ simulates $ \fgvrf $ as described but with the following difference: whenever $ \fgvrf $ sets up $ \evaluationslist[\msg,W] $, it queries $ \msg,W $ to the random oracle $ \hash $. $ \bdv $ simulates the random oracle $ \hash $  as a usual random oracle.
	The only difference from the simulation of $ \hash $ by $ \simulator $ is that $ \bdv $ does not ask for the output of $ \hash(\msg,W) $ to $ \fgvrf $; however, it does not make any difference because now $\fgvrf $ requests for it.  
	%Remark that since $ \hashG $ is not simulated as in Figure \ref{oracle:HgnoPK}, $ \bdv $ cannot check whether $ W $ is an anonymous key generated by an honest secret key or not.  However, it does not need this information because $ \hash $ is simulated as a usual random oracle. 
	$ \bdv $ also simulates $ \hash_\ring $ for the ring commitments as a usual random oracle. 			
	Simulation of $ \hashG $ by $ \bdv $ returns $ hU $ instead of $ hG $. 
	%			
	%			\begin{figure}
		%				\centering
		%				
		%				\noindent\fbox{%
			%					\parbox{\columnwidth}{%
				%						\underline{\textbf{Oracle $ \hash$}} \\
				%						\textbf{Input:} $ m,W $ 
				%						
				%						\textbf{if} $ \mathtt{\hash}[m,  W] = \perp $
				%						
				%						\tab{$ y \leftsample \{0,1\}^{\ell_\rVRF} $}
				%						
				%						\tab{$  \mathtt{\hash}[m,  W]:=y $}
				%						
				%						
				%						\textbf{return $  \mathtt{\hash}[m, W] $}
				%						
				%				}}	
		%				\caption{The random oracle $ \hash $}
		%				\label{oracle:HbyB}
		%			\end{figure}
	
	%			\begin{figure}
		%				\centering
		%				
		%				\noindent\fbox{%
			%					\parbox{\columnwidth}{%
				%						\underline{\textbf{Oracle $ \hashG $}} \\
				%						\textbf{Input:} $ m$ \\
				%						\textbf{if} $\mathtt{oracle\_H_p}[m] = \perp  $
				%						
				%						\tab{$ h \leftsample \FF_p $}
				%						
				%						
				%						\tab{$ P \leftarrow hU $} 
				%						
				%						\tab{$\mathtt{oracle\_H_p}[m] := h$}
				%						
				%						\textbf{else}:
				%						
				%						\tab{$ h \leftarrow \mathtt{oracle\_H_p}[m] $}
				%						
				%						\tab{$ P \leftarrow hU$}
				%						
				%						\textbf{return $ \In$}
				%						
				%				}}	
		%				\caption{The random oracle $ \hashG $}
		%				\label{oracle:HgbyB}
		%			\end{figure}
	
	
	During the simulation, when $ \adv $ outputs a signature $ \sigma = (\compk,\pi_{ring}, \allowbreak \pi_{eval}, \allowbreak \comring,W) $ of an input  $ \msg $ and message $ \aux $ which is not recorded in $ \bdv $'s record as $ \fgvrf $ has, $ \bdv $ runs $ \rVRF.\Verify(\comring,\msg, \aux, \sigma) $. If it verifies, it runs the extractor algorithm of $ \NIZK_{\Rring} $ and obtains $ b, \openring, \sk $ in version 1 and obtains $ b, \openring $ in version 2. In both cases, the simulation is the same because $ \bdv $ does not need $ \sk $.  Since $\openring = (\pk, \picomring)$ contains a valid proof,  it obtains $ \ring $ by running the extractor algorithm of $ \NARK_{\relcomring} $.  	
	 Then, it computes $ X = \compk - \openpk \, \genB $.
	If $ \pk $ is not an honest key, then $\bdv $ adds $ W $  to $ \anonymouskeylist[m, \ring] $.  
	%If $ \pk $ is not a malicious key but $ X $ is  generated for honest parties by $ \bdv $ while simulating $ \simulator $, $ \bdv $ aborts \footnote{This case never happens if $ \pk  $ is defined $ \sk\genG $}. The abort case happens with a negligible probability because all the outputs seen by the adversary are independent from $ X $.
	Then, it  runs the extractor algorithm of $ \NIZK_{\rcom} $ and obtains $(\hat{x},\hat{\openpk} )$ such that $ \compk = \hat{x}\genG + \hat{\openpk} \, \genB $ and $ W = \hat{x} \hashG(m) $. If  $ W \notin \anonymouskeylist[\msg, \ring] $, $ \bdv $ increments  $ \counter[\msg,\ring] $ and adds $ W $ to $ \anonymouskeylist[\msg,\ring] $.
	
	If $ X  $ is generated by $ \bdv $ during a key generation process of an honest party and $ X = \hat{x}G $, $ \bdv $ solves the CDH problem as follows: $ W = \hat{x} h U $ where $ h = \mathtt{H_p}[m] $. Since $ X = r V $, $ W = xhuG =rhuV $. So, $ \bdv $ outputs $ r^{-1}h^{-1}W $ as a CDH solution and the simulation ends. Note that this case happens when $ \simulator $ aborts due to \ref{cond:forgery}.
	
	If $ \anonymouskeylist[m,\ring] =t' > |\ring_{mal}| =t$, $ \bdv $ obtains all the signatures $ \{\sigma_i\}_{i =1}^{t'} $ that makes $ \bdv $ add an anonymous key to $ \anonymouskeylist[m,\ring] $. Then it solves the CDH problem as follows. Note that this case happens when $ \simulator $ aborts because of C\ref{cond:uniqueness}.
	
	For all $ \sigma_j =(\compk_j,\pi_{ring_j},\comring, \pi_{eval_j},W_j) \in \{\sigma_i\}_{i =1}^{t'} $, $ \bdv $ runs the extractor for $ \Rring $ and obtains $\openring_j, \openpk_j, \sk_j$ in version 1 and $ (\openring_j, \openpk_j) $ in version 2. Then it obtains the public key $ \pk_j \in \openring_j$ where $ \pk_j \in \ring $ and  $ X_j = \compk- \openpk_j \genB = x_j \genG $.
	%\footnote{The reason that we do not use $ x_j $ while computing $ X_j $ is that to show that $ \Rring $ does not need $ \sk = (x_j,r_j) $ as a witness if $ \rVRF.\KeyGen $ generates $ \pk  $ as $ \sk\genG $. So, we want to show that $ \bdv $ can solve CDH even if $ \sk $ is not the part of the witness of $ \Rring $}. 
	It then adds $ X_j $ to a list $ \setsym{X}  $ and $ \pk_j $ to a set $ \setsym{PK} $. One of the following cases happens:
	
	\begin{enumerate}
		
		\item All $ X_j $ in $ \setsym{X} $ are different  and $ |\setsym{PK}| \leq t $:  This only happens if we are in version 1. Because in version 2, $ \pk = x_j \genG = X_j$. In version 1, each $ \pk_j \in \setsym{PK} $ commits to a secret key $ x_j $ such that $ x_j = \mathsf{Com}.\mathsf{Open}(\pk_j, r_j) $. If all $ X_j $'s are different and  $ |\setsym{PK}| \leq t $, then there exists a $ \pk_j \in \setsym{PK} $ where $ x_j = \mathsf{Com}.\mathsf{Open}(\pk_j, r_j) $ and $ x'_j = \mathsf{Com}.\mathsf{Open}(\pk_j, r'_j) $ such that $ x_j \genG, x_j'\genG \in \setsym{X} $. Thus, the binding property of $ \mathsf{Com} $ is broken, which occurs with negligible probability. Therefore, $ \bdv  $ aborts with a negligible probability. 
		
		\item All $ X_j $ in $ \setsym{X} $ are different and $ |\setsym{PK}| > t $: If $ \bdv $ is in this case, it means that there exists $ X_a \in \setsym{X} $ which belongs to an honest party because $ \setsym{PK} $ includes more keys than the malicious keys. This cannot happen at this point because $ \bdv $ solves the CDH when $ \adv $ output $ \sigma_a $ when this happens as described above. 
		%Then $ \bdv $ runs the extractor algorithm of $ \NIZK_{\rcom} $ and obtains $ \hat{\sk}_a, \hat{\openpk} $ such that $ \compk_a = \hat{\sk}_a\genG + \hat{\openpk}_a \,\genB $ and $ W_a = \hat{\sk}_a \hashG(m) $.  If $ \bdv $ is in this case, $ \hat{\sk}_a\genG\neq X_a $ because otherwise it would solve the CDH as described before. Therefore, $ \openpk_a \neq \hat{\openpk}_a $. Since $ X_a + \openpk_a \, \genB = \hat{\sk}_a\genG + \hat{\openpk}_a \,\genB  $ and $ X_a = r_aV $ where $ r_a $ is generated by $ \bdv $ during the key generation process, $ \bdv $ obtains a representation of $ V = \gamma \genG + \delta \genB $ where $ \gamma = \hat{\sk}_ar^{-1}_a  $ and $ \delta = (\hat{\openpk}_a -\openpk)\,r_a^{-1} $. Then $ \bdv $ stores $ (\gamma, \delta) $ to a list $ \mathsf{rep} $. If $ \mathsf{rep} $ does not include another element $ (\gamma', \delta')  \neq (\gamma, \delta) $, $ \bdv $ rewinds $ \adv $ to the beginning with a new random coin.  Otherwise, it obtains $ (\gamma', \delta') $ which is another representation of $ V $ i.e., $ V = \gamma' \genG + \delta' \genB $. Thus, $ \bdv $ can find discrete logarithm of $ V $ on base $ G $ which is $ v = \gamma + \delta \theta $ where $ \theta = (\gamma - \gamma')(\delta' - \delta)^{-1} $. $ \bdv $ outputs $ vU $ as a CDH solution.
		\item  There exist at least two $ X_a,X_b \in \setsym{X} $ where $ X_a = X_b $: $ \bdv $ runs the extractor algorithm of $ \NIZK_{\rcom} $ for $ \pi_{ring_a} $ and $ \pi_{ring_b} $ and obtains $(\hat{x}_a,\hat{\openpk}_a )$ and $(\hat{x}_b,\hat{\openpk}_b )$, respectively\eprint{ such that $ \compk_a = \hat{x}_a\genG + \hat{\openpk}_a \, \genB \compk_b = \hat{x}_b\genG + \hat{\openpk}_b \, \genB $ and $ W_a = \hat{x}_a \hashG(m), W_b = \hat{x}_b \hashG(m) $}{}. Since $ W_a \neq W_b $, $ \hat{x}_a \neq \hat{x}_b $. So, $ \bdv $ can obtain two different and non trivial representations of $ X_a = X_b $ i.e., $ X_a = X_b = \hat{x}_a\genG + (\hat{\openpk}_a - \openpk_a) \, \genB = \hat{x}_b\genG + (\hat{\openpk}_b - \openpk_b) \, \genB $. Thus, $ \bdv $ finds the discrete logarithm of $ K = U $ in base $ G $ which is $ u = \frac{\hat{x}_a - \hat{x}_b}{\hat{\openpk}_a -\openpk_a -\hat{\openpk}_b + \openpk_b} $. $ \bdv $ outputs $ uV $ as a CDH solution.
	\end{enumerate}
	
	
	
	
	
	
	
	
	
	
	
	
	%	
	%		
	%		
	%			$ \bdv $ solves CDH if $ \bdv $ is in the abort case of simulation of $ \hash$ in Figure \ref{oracle:H} by outputting $ r^{-1}h^{-1}W $ is the CDH solution of $ U,V $. $ r^{-1}h^{-1}W $ is the CDH solution because $ vU $ is a solution of $ CDH $ where $ V =  $
	%		
	%		is in this case $ \bdv $ outputs  $ r^{-1}h^{-1}W $  where $ X^* = rV $ and $ h = \mathtt{oracle\_H_p}[m,\ring] $ and simulation ends. Remark that if $ \bdv $ aborts during the simulation of $ \hash $ it means that $ X^* $ belongs to an honest party and $ X^* =  h^{-1}W = rV = rvG$.  Therefore, $ r^{-1}h^{-1}W $ is the CDH solution of $ U,V $.
	%				  
	%		During the simulation if $ \bdv $ sees a valid forgery ring signature  $ m, \ring, \sigma = (\pi_{eval}, \pi_{ring}, C, W) $ where $ W $ is an anonymous key generated by $ \bdv $ for $ (m',\ring') \neq (m, \ring) $, $ \bdv $ aborts. $ \Pr[x\hashG(m',\ring') = W; xG \in \ring'| \ring',W] $ is negligible because $ \hashG $ is a random oracle.
	%		%TODO exact probability
	%				  
	
	%		During the simulation if $ \bdv $ sees a forgery ring signature  $ m, \ring, \sigma = (\pi_{eval}, \pi_{ring}, C, W) $ where $ X = h^{-1}W $ is an honest key, then $ \bdv $ does the following: It runs the extractor algorithms on $ \pi_{ring} $ i.e., $ \ext(\rsnark,..) $ and obtains $ X' \in \ring $ and $ \openpk' $ where $ C = X' + \openpk' K $ and $ \pi_{eval} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ where $ C = x\genG + \openpk K$ and $ W = x\hashG(m, \ring)= xhV$.  Then, $ \bdv $ outputs the CDH of $ U, V $ which is $r^{-1}xU  $. This is correct CDH solution because $ X= rV = xG $, $ V= r^{-1}xG $.
	%		We remark  a forgery signature corresponds to the abort case of $ \simulator $ during the verification because $ \fgvrf $ is in \ref{cond:forgerymalicious}, $ \pk_\simulator  $ is an honest party's key. 
	
	%		During the simulation if $ \bdv $ sees $  k > |\ring_m| $-valid and malicious ring signatures $ \{\sigma_1, \sigma_2, \ldots,\sigma_k\} $ of the message $ m$ signed by $\ring $ whose anonymous keys are $ \{W_1, W_2, \ldots, W_k\} $, respectively , it runs $ \ext(\rsnark,..) $ for each valid malicious signatures $ \sigma_i $(signatures that are not generated by $ \bdv $) and obtains $ \openpk'_i, X'_i \in \ring $. In this case, the one of following two cases must happen:
	%		
	%		\begin{itemize}
		%			\item There exists $ X'\in \ring$ which is an honest key. In this case, $ \bdv  $ runs $ \pi_{eval} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ and stores $ r V = x^*\genG + (\openpk - \openpk')K = x^*\genG + b K$ to $DB $. If $ DB $ is empty, rewind $ \adv $ to the beginning of the simulation. If it is not empty i.e., there exists $ \hat{r}X = \hat{x} \genG + \hat{b}K $, then $ \bdv $ first checks whether $ r = \hat{r} $. If it is the case, it aborts. If it is not the case, it finds the discrete logarithm of $ G=U $ on base $ K $ which is $ t = \frac{\hat{r}^{-1}\hat{b}^*-{r}^{-1}b}{{r}^{-1}\hat{x}-\hat{r}^{-1}\hat{x}} $.  Then, it outputs the CDH of $ U,V $ which is $ tV $. 
		%			We remark that $ \bdv $ aborts after rewinding with a negligible probability because it selects $ r $ randomly.
		%			%TODO exact probability
		%			\item  There exists $ X' \in \ring$ which is the  output of two different signatures.
		%		\end{itemize}
	%		
	%		
	%		During the simulation if $ \bdv $ sees a valid ring signature  $ m, \ring, \sigma = (\pi_{eval}, \pi_{ring}, C, W) $ where $ X = h^{-1}W \notin \ring$, then $ \bdv $ does the following: It runs the extractor algorithms on $ \pi_{ring} $ i.e., $ \ext(\rsnark,..) $ and obtains $ X' \in \ring $ and $ \openpk' $ where $ C = X' + \openpk' K $ and $ \pi_{eval} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ where $ C = x\genG + \openpk K$ and $ W = x\hashG(m, \ring)= xhV$. In this case, $ X \neq X' $, so $ \openpk \neq \openpk' $. 
	%				  
	%				  
	%		\begin{itemize}
		%			\item If $ X' $ is honest, then store $ r V = x^*\genG + (\openpk - \openpk')K = x^*\genG + b K$ to $DB $. If $ DB $ is empty, rewind $ \adv $ to the beginning of the simulation. If it is not empty i.e., there exists $ \hat{r}X = \hat{x} \genG + \hat{b}K $, then $ \bdv $ first checks whether $ r = \hat{r} $. If it is the case, it aborts. If it is not the case, it finds the discrete logarithm of $ G=U $ on base $ K $ which is $ t = \frac{\hat{r}^{-1}\hat{b}^*-{r}^{-1}b}{{r}^{-1}\hat{x}-\hat{r}^{-1}\hat{x}} $.  Then, it outputs the CDH of $ U,V $ which is $ tV $. 
		%			We remark that $ \bdv $ aborts after rewinding with a negligible probability because it selects $ r $ randomly.
		%			%TODO exact probability
		%				  	
		%			\item If $ X' $ is  a malicious key, $ \bdv $ runs the extractor algorithm on PoK proof $ \pi_{dl} $ of $ X' $ i.e., $ \ext(\rdl,..,) $ which outputs $ x' $ where $ X' = x'G $. Since $ x' \neq x^* $, $ \bdv  $ has a Pedersen commitment $ C $ with two openings so it can find the discrete logarithm of $ K$ on base $ G $ which is $ t = \frac{x^* - x'}{\openpk' - \openpk^*} $.  In the end, it outputs the CDH of $ X,Y $ which is $ tU $. 
		%
		%		 \end{itemize}
	%		
	%	
	So, the probability that $ \bdv $ solves the CDH problem is equal to the probability that $ \adv $ breaks the forgery or uniqueness of the real protocol. Therefore,  if there exists $ \adv $ that makes $ \simulator$ abort during the verification, then we can construct an adversary $ \bdv $ that solves the CDH problem, breaking the binding property of $ \mathsf{Com} $ except with a negligible probability.
	
	
	
\end{proof}
This completes the security proof of our first ring VRF construction.\eprint{ \qed}{\qed}



\subsection{Security of Our Protocol with $ \SpecialG $}
\label{ap:secondprotocolproof}
%\begin{theorem}
%Our specialized $ \rVRF $   over  $ pp_{rvrf} $ realizes $ \fgvrf $ running $ \Gen_{sign} $ (Algorithm \ref{alg:gensignSG}) \cite{canetti1,canetti2} in the random oracle model assuming that $\ZKCont $ is zero-knowledge and knowledge sound as defined in Definition \ref{def:zk_cont} and $ \NIZK_{\mathcal{R}_{eval}} $ is zero-knowledge and knowledge sound, the decisional Diffie-Hellman (DDH) problem are hard in $ \grE  $ \eprint{(so the CDH problem is hard as well)}{} and the commitment scheme $ \mathsf{Com} $ is binding and perfectly hiding. 
%\end{theorem}
%
%Before we start to analyse our protocol, we should define the algorithm $ \gen_{sign} $  for $ \fgvrf $ and show that $ \fgvrf $ with $ \gen_{sign} $ satisfies the anonymity defined in Definition \ref{def:anonymity}. It is very similar to Algorithm \ref{alg:gensign}.


\begin{lemma} \label{lem:anonymitySG} $ \fgvrf $ running Algorithm \ref{alg:gensignSG} satisfies anonymity (Definition \ref{def:anonymity}) assuming that $\ZKCont $ is a zero-knowledge as defined in Definition \ref{def:zk_cont}.
\end{lemma}

\begin{proof}
We simulate $ \fgvrf $ with Algorithm \ref{alg:gensign} against $ \mathcal{D} $. Assume that the advantage of $ \mathcal{D} $ is $ \epsilon $. Now, we reduce the anonymity game to the following game where we change the simulation of $ \fgvrf $ by changing the Algorithm \ref{alg:gensign}. In our change, we replace Line 2 and 3 of Algorithm \ref{alg:gensignSG} with $ \ZKCont.\Sim(\mathsf{td}, \comring,\relinner) $. Since $ \ZKCont$ is zero-knowledge, there exists an algorithm  $ \ZKCont.\Sim$ that generates a proof which is indistinguishable from the original proof and $ \compk $. Therefore, our reduced game is indistinguishable from the anonymity game. Since in this game, no  key is used while generating the proof and $ W $ and $ \compk $ is perfectly hiding, the probability that  $ \mathcal{D} $ wins the game is $ \frac{1}{2} $. This means that $ \epsilon $ is negligible.		
\end{proof}


We construct the same $ \simulator $ described in the proof of Theorem \ref{thm:firstprotocol} because it does not deploy any extractor or simulator of $ \NIZK $ for $ \rel_{eval} $ and $ \Rring $. Similarly, Lemma \ref{lem:honestoutput} applies here. The only difference is in Lemma \ref{lem:simulation-ind}, since $ \Gen_{sign} $ is different than Algorithm \ref{alg:gensign}.
We first replace $ \Gen_{sign} $ run by $ \bdv $ in Algorithm \ref{alg:gensignbdv} defined for Lemma \ref{lem:simulation-ind} with Algorithm \ref{alg:gensignSGbdv}.

\begin{algorithm}
\caption{$\gen_{sign}(\ring,W,\pk,\aux,m)$}
\label{alg:gensignSGbdv}	 	
\begin{algorithmic}[1]
	%					\State $ c,s_1, s_2 \leftsample \FF_p $
	%					\State $ \pi_{eval}  \leftarrow (c,s_1, s_2)$
	%\State $ \openpk \leftsample \FF_p $
	\State $ \comring, \openring \leftarrow \rVRF.\CommitRing(\ring) $
	\State $ \piring,\compk \leftarrow \ZKCont.\Simulate(\mathsf{td},\comring) $ 
	\State $ \pieval \leftarrow \NIZK_{\mathcal{R}_{eval}}.\Simulate(\compk, W,m) $
	%					\State $ R' = s\genG +\delta K + c\compk$
	%					\State $ R_m = s\hashG(m) + c W $
	%					\State $ \aux' = \tmpaux $
	%					\State $ \mathtt{H_p}[\aux',m, \compk,W,R',R'_m] = c$						
	\State\Return$ \sigma = (\compk, \pi_{\mathtt{inner}},\comring, \pieval) $
\end{algorithmic}

\end{algorithm}

The other change is that we replace all extractors in Lemma \ref{lem:simulation-ind} for $ \Rring, \rel_{eval} $ with the extractor  for $ \NIZK_{\relrvrf} $. $ \bdv $ here is simpler than $ \bdv$ in Lemma \ref{lem:simulation-ind} because the secret key is the part of  $\relrvrf$ while the secret key is not part of the witness in $ \Rring $ for the case $ \pk $ is defined as $ \sk\genG $ (Version 2).
When $ \bdv $ sees a signature $ \sigma = (\compk, \pi_{\mathtt{inner}},\comring, \pieval)  $ of $ \msg $, it runs the extractor for $ \NIZK_{\relrvrf} $ and obtains $ x,r, \openring $. Then, it lets $ X $ be $ x\genG $. If $ X $ is generated for an honest party, it solves the CDH as described in Lemma \ref{lem:simulation-ind} for the same case. If $ \anonymouskeylist[\msg,\ring] = t' > |\ring_{mal}| = t$, it runs the extractors for $ \NIZK_{\Rring} $ of all malicious signatures of $ \msg $ for $ \ring $ and obtains $ \{(x_j,r_j,\openring_j)\}_{j = 1}^{t'}$. Then, for all $ j \in [1,t']$, it adds $ X_j = x_j \genG $ to $ \mathcal{X} $ and $ \pk_j  = \rVRF.\OpenRing(\comring,\openring)$ to a list $ \mathcal{PK} $. Then, the first two cases in Lemma \ref{lem:simulation-ind} happen and $ \bdv $ behaves the same.
We note that here all $ \sk_j $'s are different because $ \PreOut_j $'s are different. Therefore, the last case in Lemma  \ref{lem:simulation-ind} does not happen.


%$ \SpecialG $'s extractor outputs  $  \sk,r,\openring $ while $ \NIZK_{\Rring} $'s extractor outputs $ \openpk $ and $ \sk $ too. Here, $ \bdv $ obtains $ X $ as follows: It obtains $ \pk = \rVRF.\OpenRing(\comring, \openring) $ and $ \sk = \mathsf{Com}.\mathsf{Open}(\pk, r) $. In the end, it lets $ X = \sk \genG $. We remark that $ \sk $ that $ \bdv $ obtains here is the committed secret key in $ \compk $ because it is guaranteed in the knowledge soundness property of $ \SpecialG $ (See Definition \ref{def:zk_cont}). Therefore, $ X $ that $ \bdv $ obtains in Lemma \ref{lem:simulation-ind} and $ X $ that is obtained in this way are the same. Therefore, the rest of the proof will be the same as Lemma \ref{lem:simulation-ind}.

