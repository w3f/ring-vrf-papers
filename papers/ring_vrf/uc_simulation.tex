% !TEX root = crypto.tex

\newcommand{\name}{rVRF}

\label{ap:ucproof}
\label{sec:ringvrfconstrnoPK}
\newcommand{\GG}{\grE}
\newcommand{\FF}{\F}
\newcommand{\hash}{H}
\newcommand{\hashG}{\hash_\grE}
\newcommand{\gen}{\mathsf{Gen}}
\newcommand{\hkeys}{\mathtt{honest\_keys}}
\newcommand{\malkeys}{\mathtt{malicious\_keys}}
\newcommand{\rcom}{\mathcal{R}_{eval}}
\newcommand{\rsnark}{\Rring}
\newcommand{\counter}{\mathsf{counter}}
\newcommand{\bdv}{\mathcal{B}}
\newcommand{\abort}{\textsc{Abort}}
\newcommand{\pkeys}{\arraysym{public\_keys}}
\newcommand{\skeys}{\arraysym{secret\_keys}}
\newcommand{\keytransform}{T_{\mathsf{key}}}
%Before giving the security proof of our protocol, we give the protocol in Section \ref{sec:pederson_vrf} without the abstraction from $ \PedVRF $ for the sake of  clarity of the security proof.
%
%We instantiate parameter generation by constructing a group $\GG$ of order $ p $ and two generators $ \genG, \genB \in  \GG$.  We consider three hash functions: $ \hash, \hash_p: \{0,1\}^* \rightarrow \FF_p $ and a hash-to-group function $\hashG : \{0,1\}^* \rightarrow \GG$ and . \name \ works as follows:
%
%\begin{itemize}
%	\item $ \rVRF.\KeyGen(1^\kappa):  $ It selects randomly a secret key $ x \in \FF_p$ and computes the public key $ X = xG $. In the end, it outputs $ \sk = x $ and $ \pk = X $.
%	
%	%It also generates  PoK for the discrete logarithm of $ X $ for the relation $ \R_{dl} $, $ \NIZK.\Prove(\rdl, (x, (X, G, \GG))) \rightarrow \pi_{dl} $.
%	
%	%\begin{equation}
%	%	\rdl = \{(x,(X,G,\GG)): X,G \in \GG, x \in \FF_p, x = xG\}
%	%\end{equation}
%	
%	%For this, it does the following: $ a \leftsample \FF_p $, $ c = \hash_p(a\genG, X) $, $ s = a + cx $. 
%	
%	%	\item $ \rVRF.\eval(\sk, \ring, m) $: It lets $ P = \hashG(m, \ring) $ and computes $ W = xP  $. Then, it outputs $ y = \hash(m, \ring, W) $. So, the deterministic function $ F $ in our rVRF protocol is $ F(\sk, \ring, m) = H(m, \ring, x\hashG(m,\ring)) $.
%	%	
%	\item $ \rVRF.\Sign(\sk, \ring, m):$ It lets $ \In = \hashG(m) $ and computes the pre-output $ \PreOut= x\In$. The signing algorithm works as follows: 
%
%	\begin{itemize}
	%		
	%		\item It first commits to its secret key $
	%		x$ i.e., $ \compk = X + \openpk \, \genB $ where $ \openpk \leftsample \FF_p $.
	%		\item It generates a Chaum-Pedersen DLEQ proof $ \pi_{eval} $ showing the following relation by running the algorithm $ \NIZK_{\rcom}.\Prove(((\genG, \genB,\GG,\compk,\PreOut,\In); (x, \openpk))) $ which outputs $ \rightarrow \pi_{eval}$
	%		\eprint{\begin{align}
			%				\rcom= \{((x, \openpk), (\genG, \genB,\GG,\compk,\PreOut,\In)): 
			%				\compk = x\genG + \openpk\, \genB, \PreOut = x \,\In \} \label{rel:commit} 
			%		\end{align}}{
		%		\begin{align}
			%			\rcom= \{((x, \openpk), (\genG, \genB,\GG,\compk,\PreOut,\In)): \\
			%			\compk = x\genG + \openpk\, \genB, \PreOut = x \,\In \} \label{rel:commit} \nonumber
			%		\end{align}}
	%		Here $ \Prove $ algorithm runs a non-interactive Chaum-Pedersen DLEQ proof with the Fiat-Shamir transform:  Sample random $r_1, r_2 \leftarrow \F_p$.
	%		Let $R = r_1 \genG + r_2 K$, $R_m = r_1 \In$, and
	%		$c = \hash_p(\ring, m, \PreOut,\compk,R,R_m)$.
	%		Set $\pi_{eval} = (c,s_1,s_2)$ where $s_1 = r_1 + c x$ and $s_2= r_2 + c \, \openpk$.
	%		\item %It obtains $ crs $ from $ \gcrs $ for the second proof by sending the message $ (\oramsg{learncrs}, \sid) $ to $ \gcrs $. Then,
	%		%It constructs a Merkle tree $ \mathsf{MT} $ with the nodes $ X_i $ where  $ X_i \in \pk_i $ and $ \pk_i \in  \ring $. We denote its  root by $ \mathsf{root} $. In the end, 
	%		It generates the second proof $ \pi_{ring} $ for the following relation with  the witness $ (\ring, x, \openpk) $. 		
	%		
	%		\eprint{\begin{equation}
			%				%\rsnark = \{((\mathsf{copath}, X, \openpk),(G,\genB\GG,\mathsf{root}, \compk)): C-\openpk K = X, \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) \rightarrow 1\} \label{rel:snark}
			%				\rsnark = \{(X, \openpk),(\genG,\genB,\GG,\ring, \compk)): \compk-\openpk \, \genB = X \in \ring\} \label{rel:snark}
			%			\end{equation}
		%		}{\begin{align}
			%			\rsnark = \{(X, \openpk),(\genG,\genB,\GG,\ring, \compk)): \\\compk-\openpk \, \genB = X \in \ring\} \label{rel:snark} \nonumber
			%		\end{align}
		%	}
	%		
	%		%Here, $ \mathsf{copath} $ is a copath of the Merkle tree $ \mathsf{MT} $. $ \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) $ is a verification algorithm of the Merkle tree which verifies whether $ X $ is the one of the leaves of $ \mathsf{MT} $ i.e., compute a root $ \mathsf{root}' $ with $ X $ and $ \mathsf{copath} $ and output 1 if $ \mathsf{root} = \mathsf{root}' $.
	%		
	%		The second proof $ \pi_{ring} $ is generated by running 
	%		$ \NIZK_{\rsnark}.\Prove(((\genG,\genB,\GG,\ring, \compk); (X, \openpk))) $ 
	%	\end{itemize}
%	In the end, $ \rVRF.\Sign $ outputs $\sigma = (\pi_{eval}, \pi_{ring}, \compk, \PreOut) $.
%	
%	\item $ \rVRF.\Verify(\ring,\PreOut, m, \sigma) $: Given $  \sigma = (\pi_{eval}, \pi_{ring},\compk)  $ and $ \ring, \PreOut $,
%	% it first runs $ \NIZK.\Verify(\rdl,(X_i,\genG,\GG), \pi_{dl_i}) $ for each $ \pk_i= (X_i, \pi_{dl_i})  \in \ring $. If each of key in $ \ring $ verifies,
%	it runs $ \NIZK_{\rcom}.\Verify((\genG, \genB,\GG,\compk,\PreOut,\In), \pi_{eval} ) $ where $ P = \hashG(m) $. $ \NIZK_{\rcom}.\Verify $ works as follows: $ \pi_{eval} = (c,s_1, s_2) $, it lets $R' = s_1 \genG + s_2 \, \genB - c \,\compk$ and $R'_m = s_1 \hashG(m) - c \, \PreOut$. It
%	returns true if $c = \hash_p(\ring,m,\PreOut,\compk,R',R'_m)$. If  $ \NIZK_{\rcom}.\Verify((\genG, \genB,\GG,\compk,\PreOut,\In), \pi_{eval} ) $ outputs 1, it runs $ \NIZK_{\rsnark}.\Verify((\genG,\genB,\GG,\ring, \compk), \pi_{ring}) $. 
%	If all verification algorithms verify, it outputs $ 1 $ and the evaluation value $ y =  \hash(m,\PreOut)  $. Otherwise, it outputs $( 0, \perp) $.
%	
%\end{itemize}
%
%\subsection{Security Analysis}

\subsection{Security Analysis of Our First Ring VRF Construction}
With $ \gen_{sign} $  for $ \fgvrf $ defined as above, we first show that  $ \gen_{sign} $ satisfies Definition \ref{def:anonymity} so that $ \fgvrf $ assures anonymity. 



%\begin{algorithm}
%	\caption{$\gen_{W}(\ring,\pk,m)$}
%	\label{alg:genW}	 	
%	\begin{algorithmic}[1]
	%		\State$ W \leftsample\GG $
	%		%		\State \textbf{get} $ X \in \pk $
	%		%		\If{$\mathtt{DB}[m, \ring] = \perp  $}		
	%		%		\State{$ a \leftsample \FF_p $}		
	%		%		\State{$\mathtt{DB}[m, \ring] := a$}
	%		%		\EndIf
	%		%		\State$ a \leftarrow \mathtt{DB}[m, \ring] $
	%		%		
	%		%		\State \textbf{return} $ aX $
	%		\State \textbf{return} $ W $
	%	\end{algorithmic}
%	
%\end{algorithm}

%\begin{algorithm}
%	
%	\caption{$\gen_{sign}(\ring,W,x,\pk,\aux,\msg)$}
%	\label{alg:gensign}	 	
%	\begin{algorithmic}[1]
	%		\State $ c,s_1, s_2 \leftsample \FF_p $
	%		\State $ \pi_{eval}  \leftarrow (c,s_1, s_2)$
	%		\State $ \openpk \leftsample \FF_p $
	%		\State $ \compk =  x \genG + \openpk \, K$
	%		%\State $ \pi_{eval} \leftarrow \NIZK.\mathsf{Simulate}(\rcom, (G, \genB,\GG,\compk,W,\In)) $
	%		%\State \textbf{send} $(\oramsg{learn\_\tau},\sid)  $ to $ \gcrs $
	%		%\State \textbf{receive} $(\oramsg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
	%		\State $ \comring, \openring \leftarrow \rVRF.\CommitRing(\ring, \pk) $
	%		\State $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\Prove(\comring, \compk\; \openpk, \openring, x) $ 
	%		\State\Return$ \sigma = (\pi_{eval},\pi_{ring},\compk,\comring,W) $
	%	\end{algorithmic}
%	
%\end{algorithm}


\begin{lemma} \label{lem:anonymity} $ \Gen_{sign}$ in Algorithm \ref{alg:gensign} satisfies the anonymity defined in Definition \ref{def:anonymity} assuming  $ \NIZK_{\rsnark} $ is zero-knowledge and the Pedersen commitment is perfectly hiding.
\end{lemma}

\begin{proof} Assume that $ \mathcal{D} $ wins the anonymity game for $ \Gen_{sign} $ with advantage $ \epsilon $.
We reduce the anonymity game to a game where we remove line \ref{rel:commit} and change line \ref{line:piring} of Algorithm \ref{alg:gensign} with $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\mathsf{Simulate}(\tw_{\Rring}, \pp_{\Rring},\comring, \compk) $ where $ \comring = \com^*(\ring) $.  Our new game is indistinguishable by the zero-knowledge property of $ \NIZK_{\rsnark} $.  Since, in the new game, proofs are generated without the keys and $ \compk $ is perfectly hiding,   $ \mathcal{D} $ wins the new game with probability $ \frac{1}{2} $. Thus, $ \epsilon $ is negligible.		
\end{proof}

%We next show that our first protocol  realizes $ \fgvrf $  in the random oracle model under the assumption of the hardness of the decisional Diffie Hellman (DDH).

%The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.

%\begin{definition}[$ n $-One-More Gap Diffie-Hellman (OM-GDH) problem]
%	Given   $ p $-order group $ \GG $ generated by $ G $, the challenges $ G, X = xG, P_1, P_2, \ldots, P_{n+1} $ and access to the DH oracle $ \mathsf{DH}(.,.,.) $ and the oracle $ \mathcal{O}_x(.) $ which returns $ x\In$ given input $ \In$, if a PPT adversary $ \mathcal{A} $ outputs $ xP_1, xP_2, \ldots, xP_{n+1} $ with the access of at most $ n $-times to the oracle $ \mathcal{O}_x $, then $ \mathcal{A}  $ solves the $ n $-OM-GDH problem. We say that $ n $-OM-GDH problem is hard in $ \GG $, if for all PPT adversaries, the probability of solving the $ n $-OM-GDH problem is negligible in terms of the security parameter.
%\end{definition}
We now state the security guarantees for our first construction when $ \pk $ is defined as $ \mathsf{Com}.\mathsf{Commit}(x,r) $ where $ \sk = (x, r) $ is the secret key (Alternative 1) and  when $ \pk $ is defined as $ \pk = \sk\genG $ where $ \sk = x $  (Alternative 2).
\liz{What are we doing with Alternative 2?}
\begin{theorem}\label{thm:firstprotocol}
	Our first ring VRF construction realizes $ \fgvrf $ running $ \Gen_{sign} $ in Algorithm \ref{alg:gensign} in the random oracle model assuming that $ \NIZK_{\mathcal{R}_{eval}} $ and $ \NIZK_{\mathcal{R}_{ring}}$ are zero-knowledge and knowledge sound, $ \NARK_{\relcomring} $ is knowledge sound, the decisional Diffie-Hellman (DDH) problem is hard in $ \grE  $ \eprint{(so the CDH problem is hard as well)}{and the commitment scheme $ \mathsf{Com} $ is computationally binding and perfectly hiding for alternative-1}. 
\end{theorem}

\begin{proof}
	We construct a simulator $ \simulator $ that simulates the honest parties in the execution of our protocol and simulates the adversary in $ \fgvrf $. 
	\begin{itemize}
		%\item \textbf{[Simulation of $ \gcrs $:] }When simulating $ \gcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rsnark) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $. Whenever a party comes to learn the $ crs $, $ \simulator $ gives $ crs $ as  $ \gcrs $.
		
		\item \textbf{[Simulation of $ \oramsg{keygen} $:]} Upon receiving $(\oramsg{keygen}, \sid, \user_i)$ from $\fgvrf$, $ \simulator $ generates  a secret and public key pair $ \sk = (x,r)$ and $\pk $ by running $ \rVRF.\KeyGen $. It adds $ \pk $ to a list $ \hkeys $  as a key of $ \user_i $.
		In the end, $ \simulator $ returns $(\oramsg{verificationkey}, \sid, \sk,\pk)$ to $\fgvrf$. 
		$ \simulator $ sets $ \pkeys[X] = \pk$ and $ \skeys[X] =(x,r) $ where $ X = x \genG $.
		During the simulation, $ \simulator $ populates $ \pkeys $ with hypothetical public keys which are never revealed during the simulation or by $ \fgvrf $. However, it does not populate $ \skeys $ except in this part of the simulation. So, if  $ \pkeys[X'] $ is not empty for a value $ X' $ but $ \skeys[X'] $ is empty, it means that $ \simulator $ generated the entry $ \pkeys[X'] $ just for the sake of the simulation with a key which is not  functional as a real public key.
		%Whenever the honest party $ \user $ is corrupted by $ \env, $ $ \simulator $ moves the key of $ \user $ to $ \malkeys $ from $ \hkeys $.
		
		\item \textbf{[Simulation of corruption:]} Upon receiving a message $ (\oramsg{corrupted}, \sid, \user_i) $ from $ \fgvrf $, $ \simulator $ removes the public key $ \pk $ from $ \hkeys $ which is stored as a key of $ \user_i $ and adds $ \pk $ to $ \malkeys $.
		
		\item\textbf{[Simulation of the random oracles:]} We  describe how $ \simulator $ simulates the random oracles $ \hashG, \hash, \hash_p $ against the real-world adversary.
		
		$ \simulator $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:HgnoPK}. It selects a random element  $ h $ from $ \FF_p $ for each new input and outputs $ hG $ as an output of the random oracle $ \hashG $. Thus, $ \simulator $ knows \emph{the discrete logarithm of each random oracle output of $\hashG  $}. 
		
		
		The simulation of the random oracle $ \hash $ is less straightforward. (See Figure \ref{oracle:HnoPK}.)
		The value $ W $ can be a $ \PreOut $ of an input generated by a malicious party or can be an anonymous key of  $ \msg $ generated by $ \fgvrf $ for an honest party. $ \simulator $ does not need to know which, but $ \hash $ should output $ \evaluationslist[\msg,W] $ in both cases to be consistent with $ \fgvrf $.	 
		%If $ W $ is a pre-output, $ \simulator $ needs to find corresponding malicious public key in the real world. If it is the case, $ W $ should be equal to $ x\hashG(m, \ring)= xhG $  where $ xG $ is a public key. 
		$ \simulator $ treats $ W $ as if it is $ \PreOut $ generated as in the protocol. So, $ \simulator $ first obtains the discrete logarithm $ h $ of $ \hashG(\msg) $ from the $ \hashG $ database and obtains $ X^* = h^{-1}W $.    
		%If $ X^* $ has not been registered as a malicious key, it registers it to $ \fgvrf $. Thus, $ \simulator $ has a right to ask the output of the message $ m, \ring $ to $ \fgvrf $. 
		$ \simulator $ checks if $ \pkeys[X^*] $ exists. If it does not exist, $ \simulator $ samples randomly a key $ \pk^* $ which is not stored in $ \pkeys $ and stores $ \pkeys[X^*] = \pk^* $ just to use while sending an $ \oramsg{eval} $ message to $ \fgvrf $. Then, it sends  $ (\oramsg{eval}, \sid,\pk^*,W,\msg) $ to $ \fgvrf $ and receives back $ \evaluationslist[\msg,W] $.
		Note that if $ W $ is a pre-output generated by $ \adv $, then $ \fgvrf $ matches it with the evaluation value given by $ \fgvrf $. If $ W $ is an anonymous key of an honest party in the ideal world, $ \fgvrf $ still returns an honest evaluation value $ \evaluationslist[\msg,W] $ even if $ \simulator $ cannot know whether $ W $ is an anonymous key of an honest party in the ideal world. 
		% Remember that $ \fgvrf $ only replies to the evaluation message of $ \simulator $ if $ W $ is not mapped to another message, ring and public key $ (m', \ring', X')   $. $ W $ cannot be map to $ (m', \ring', X')   \neq  (m, \ring, X*)   $ because it would be aborted during the simulation $ \hashG $ if they were mapped to $ W $.
		During the simulation of $ \hash $, if $ \fgvrf $ aborts, then there exists $ W' \neq W $ such that $ \anonymouskeymap[\msg,W'] = \pk^* $. Note that it is not possible because, if it does occur, it means that $ hX^* = W' \neq W  $ where $ \pkeys[X^*] = \pk^* $, but also $ W = hX^* $. 
		Therefore, \abort-1 never occurs.
		
%		We note that the anonymous keys for honest parties generated by $ \fgvrf $ are independent from their keys. Therefore, if $ \skeys[h^{-1}W] $ is defined, $ \simulator $ returns a random value because  $ \evaluationslist[\msg,W] $ is not defined or will not be defined in $ \fgvrf $ in this case except with a negligible probability. If it is ever defined, i If it ever happens it means that $ \fgvrf $ selects randomly $ W  $ randomly which actually equals to $ hX^*$. If such things happen in $ \fgvrf $, $ \env $ distinguishes the simulation via honest signature verification in the real world. So, this case is covered in our simulation in Figure \ref{oracle:Hout}.
		

		\begin{figure}
			\begin{minipage}{.4\textwidth}

				\centering
				\noindent\fbox{%
					\parbox{2cm}{%
						\scriptsize
						\underline{\textbf{Oracle $ \hashG $}} \\
						\textbf{Input:} $ \msg $ \\
					
						\textbf{if} $\mathtt{\hashG}[\msg] = \perp  $
						
						\tab{$ h \leftsample \FF_p $}
						
						%					\tab{\textbf{for all} $ X \in \ring $}
						%					
						%					\tab{$ W =  hX $}
						%					
						%					\tabdbl{\textbf{if} $ W \in \anonymouskeylist $: \textsc{Abort}}
						%					
						%					\tabdbl{\textbf{else:} \textbf{add} $ W $ \textbf{to} $ \anonymouskeylist $}
						\tab{$\mathtt{\hashG}[\msg] := h$}
						
						\tab{\textbf{return} $ h\genG $} 
						
						\textbf{else}:
						
						\tab{$ h \leftarrow \mathtt{\hashG}[\msg] $}
						
						\tab{$\mathtt{\hashG}[\msg] := h$}
						
						\tab{\textbf{return} $  h\genG$}
						
						
				}}	
				\caption{The random oracle $ \hashG $}
				\label{oracle:HgnoPK}

			\end{minipage}%
			\begin{minipage}{0.6\textwidth}
				\centering
				\scriptsize
				\noindent\fbox{%
					\parbox{6cm}{%
						\underline{\textbf{Oracle $ \hash$}} \\
						\textbf{Input:} $ \msg,W $ 
						
						\textbf{if} $\mathtt{\hash}[\msg, W] \neq \perp $
						
						\tab{\textbf{return $ \mathtt{\hash}[\msg,  W] $}}
						
						%					\textbf{send} $ (\oramsg{request}, \sid, \emptyset,W, m) $ \textbf{to} $ \fgvrf $
						%					
						%					\textbf{receive} $ (\oramsg{requests}, \sid, \emptyset, W, m, \setsym{L}_\sigma, y) $ \textbf{from} $ \fgvrf $
						
						%					\textbf{if} $ y = \perp $
						
					%	{$ P \leftarrow \hashG(\msg) $}
						
						{$ h \leftarrow \mathtt{\hashG}[\msg] $}
						
						{$ X^* := h^{-1}W $ // candidate commitment key} 
						
%						{{\textbf{if} $\skeys[X^*] = \perp$ }} 
						
						{\textbf{if} $ \pkeys[X^*]  = \perp$}
						
						\tabdbl{$ \pk^* \leftsample \grE $} %TODO put the space of pk's
						
						\tabdbl{$ \pkeys[X^*] := \pk^* $}
						
						{\textbf{send} $ (\oramsg{eval}, \sid, W, \pkeys[X^*] , \msg) $ \textbf{to} $ \fgvrf $}
						
						{\textbf{if} $ \fgvrf $ ignores: \abort-1}
						
						{\textbf{receive} $ (\oramsg{evaluated}, \sid, W, \msg, \Out) $ \textbf{from} $ \fgvrf $}
						
						{$ \mathtt{\hash}[\msg, W]:=\Out $}
						
%						{\textbf{else:} }
%						
%						\tab{$ y \leftsample \FF_p $}
%						
%						\tab{$ \mathtt{\hash}[m,  W]:=y $}
						%					{\textbf{else:} $\mathtt{\hash}[m, \ring, W]  = \perp$}
						%					
						%					%\tab{\textbf{return} \textsc{Abort}}
						%					\tab{$ y \leftsample \bin^\lambda $}
						%					
						%					\tab{$\mathtt{hash}[m, \ring, W] := y $}
						
						%	\textbf{else:} $ \mathtt{\hash}[m,  W]:=y $
						
						\textbf{return $ \mathtt{\hash}[\msg,  W] $}
						
				}}	
				\caption{The random oracle $ \hash $}
				\label{oracle:HnoPK}
			\end{minipage}
		\end{figure}
		


		The simulation of the random oracle $ \hash_p $ (Figure \ref{oracle:Hout}) given the query $ (\aux', \msg,\compk,W,R,R_m)  $ makes sure that the verified signature $ \sigma = (\pieval, \piring, \compk, \comring) $ of honest parties verifies $ \pieval = (c, s_1,s_2) $ via $ H_p $ as in the protocol. For this, it first parses $ \aux' $ as $\tmpaux $. \liz{Reminder to define this notation in Prelims.} If $ \piring $ is verified via $ \NIZK_{\mathcal{R}_{ring}} $, then the oracle $ H_p $ deduces that the reply to this oracle query might be obtained from $ \fgvrf $ in case $ \compk,\piring,\comring $ are  a part of a valid honest signature.
		 If the oracle $ H_p $ obtains such verified signature $ \sigma $ from $ \fgvrf $, it returns $ c $ if $ R = s_1 \genG + s_2 \genB - c \,\compk $ and $ R_m = s_1 \hashG(\msg) - cW $. We remark that if $ R $ and $ R_m $ satisfy these equalities, it means that they correspond to $ R $ and $ R_m $ generated during $ \rVRF.\Verify $, which is supposed to output 1  for the part of $ \pieval $.
		 
		
%		We remind that if an anonymous key $ W $   for an input  $ \msg$  equals to a pre-output generated by $ \rVRF.\Sign $  for an honest party's key and the the input $ \msg $, then $ \env $ can distinguish the ideal and real world outputs. The reason of this is that the evaluation value in the ideal world and real world for $ \msg,W $ will be different because of the simulation of the random oracle $ \hash $ i.e., $\mathtt{\hash}[\msg,W] \neq \evaluationslist[\msg,W] $.  Therefore, $ \simulator $ aborts if it is ever happen.
		
		\begin{figure}
			\centering
			\scriptsize
			\noindent\fbox{%
				\parbox{\textwidth}{%
					\underline{\textbf{Oracle $ \hash_p $}} \\
					\textbf{Input:} $ (\aux', \msg,\compk,W,R,R_m) $ \\					
					
					\textbf{parse} $ \aux' $ as $\tmpaux $
%					
%					{$ h := \mathtt{\hashG}[m,W] $ }
%						
%					{\textbf{if} $ \skeys[h^{-1}W] \neq \perp $: \abort-2}
					
					\textbf{if} $ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m] \neq \perp $: \textbf{return} $ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m] $
					
					
					\textbf{else if} \textbf{ $ \NIZK_{\Rring}.\Verify((\compk,\comring);\piring) \rightarrow 1 $}
					
					\tab{\textbf{send} $ (\oramsg{request\_signatures},\sid, \aux, W,\msg) $}
					
					\tab{\textbf{receive} $ (\oramsg{signatures},\sid,\msg, \setsym{L}_\sigma) $}
					
					\tab{\textbf{if} $ \exists \sigma', \sigma \in \setsym{L}_\sigma $ such that $\sigma = (\piring, \compk, \comring, .,W)  $ \textbf{and} $  \sigma' = (\piring, \compk, \comring, .,W) $}
						
					\tabdbl{ \abort-2}
					
					\tab{\textbf{else if} $\exists \sigma \in \setsym{L}_\sigma $ such that $\sigma = (\piring, \compk, \comring, \pieval, W)  $ for some $ \pieval $}
					
					\tabdbl{\textbf{get} $ \pieval = (c,s_1, s_2) $} 
					
					\tabdbl{\textbf{if} $ R = s_1\genG + s_2 \genB -c\compk, R_m = s_1 \hashG(\msg) - c W $}  
					
				
					
					
				
					
				%	\tabdbldbl{\textbf{if} $( \mathtt{H_p}[\aux, m,\compk,W,R,R_m] = c' \in \FF_p$ where $ c' \neq c $: \abort-4 }
					
					
					
					
%					\tabdbldbl{\textbf{else if} $ \mathtt{H_p}[\aux, m,\compk,W,R,R_m]  = \perp $}
					
					\tabdbldbl{$ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m]  := c$}
			
	
					\textbf{if} $ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m]  = \perp $
					
					\tab{$ c \leftsample \FF_p $}
					
					\tab{$ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m]  := c$}
					
					{\textbf{return} $  \mathtt{H_p}[\aux',\msg,\compk,W,R,R_m]   $}
					
 			}}
			\caption{The random oracle $ \hash_p $}
			\label{oracle:Hout}
		\end{figure}
		
		
		%		\item \textbf{[Simulation of $ \oramsg{sign} $]} 
		%		The simulator has a table  $\preoutputlist $ to keep the pre-outputs that it selects for each input and the ring of public keys. 
		%		Upon receiving $(\oramsg{sign}, \sid, \ring, m, y)$  from the functionality $\fgvrf$, $ \simulator $ generates the signature $ \sigma $ as follows:
		%		
		%		For the first proof, it samples $ c, s_1, s_2 \in \FF_p $ and $ \compk, W \in \GG$. Then, it lets the first proof be $\pi_1 =  (c, s_1, s_2) $. 
		%		In addition, it sets $ R = sG+ \delta K+ c\compk $ and $ R_m = s \hashG(m, \ring)+ cW $ and maps the input $ \ring,m, W,\compk, R, R_m$ to $ c $ in the table of the random oracle $ \hash_p $ so that $ \pi_1 $ verifies in the real-world execution.  
		%		It adds $ W $ to the list $ \preoutputlist[m, \ring] $.
		%		
		%		$ \simulator $ gets the trapdoor $ \tau $ that it generated during the simulation of $ \gcrs $ to simulate the second proof. Then, it runs $ \mathsf{SNARK}.\mathsf{Simulate}(\rsnark,\tau, crs) $ and obtains $ \pi_2 $.
		%		
		%		In the end, $ \simulator $  responds by sending the message $(\oramsg{signature}, \sid, \ring, m, \sigma = (\pi_1, \pi_2, \compk, W))$ to the $ \fgvrf $.  It also lets $\mathtt{\hash}[m, \ring, W] $ be $ y $, if it is not defined yet. If it is defined with another value $ y' \neq y $, then it aborts.
		%TODO: Talk about this abort case happens with a negl probability. 
		
		
		\item \textbf{[Simulation of $ \oramsg{verify} $]} Upon receiving  $(\oramsg{verify}, \sid, \ring,W, \aux,\msg, \sigma)$ from the functionality $\fgvrf$, $ \simulator $ runs the $ \rVRF.\Verify $ algorithm of our ring VRF protocol. If  it verifies, it sets $ b_{\simulator} =1 $. Otherwise it sets $ b_{\simulator} =0  $.
		
		\begin{itemize}
			\item 		If $ b_\simulator = 1 $, it sets $ X = h^{-1} W$ where $ h = \mathtt{\hashG}[m] $. Then it obtains $ \pk  = \pkeys[X]$ if it exists. If it does not exist, it picks a $ \pk  $ which is not stored in $ \pkeys $ and sets $ \pkeys[X] = \pk $. Then it sends  $ (\oramsg{verified}, \sid, \ring, W,\aux,\msg, \sigma, b_\simulator, \pkeys[X]) $ to $ \fgvrf $ and receives back $ (\oramsg{verified}, \sid, \ring, W, \aux, \msg, \sigma, \Out, b) $. 
			
			 If $ b \neq b_\simulator $, it means that the signature is not a valid signature in the ideal world, while it is in the real world. So, $ \simulator $ aborts in this case (\abort-3).
				If $ \fgvrf $ does not verify a ring signature even if  it is verified in the real world, $ \fgvrf $ is in either C3-\ref{cond:uniqueness}, \ref{cond:forgery} or C3-\ref{cond:differentWforsamepk}.
				If $ \fgvrf $ is in C3-\ref{cond:uniqueness}, it means that $ |\anonymouskeylist[\msg,\ring]|> |\ring_{mal}| $. If $ \fgvrf $ is in C3-\ref{cond:forgery}, it means that $ \pk$ belongs to an honest party but this honest party never signs $ \msg $ and $ \aux $ for  $ \ring $. So, $ \sigma $ is a forgery.	 If $ \fgvrf $ is in C3- \ref{cond:differentWforsamepk}, it means that there exists $ W' \neq W $ where $ \anonymouskeymap[\msg,W'] = \pk$. If $ [\msg,W'] $ is stored before, it means that $ \simulator $ obtained $ W' = hX $ where $ h =\mathtt{\hashG}[\msg] $.  However, this cannot occur since $ W = hX $.
			
				 If $ b = b_\simulator $, it sets $\mathtt{\hash}[\msg,W] = \Out $, if it is not defined before.
				% In short, if $ \simulator $ aborts because $ b\neq b_\simulator $ it means either $ W $ of an honest party is not unique and $ \adv $ in the real world generates a forgery signature of $ (m, \ring, \sigma) $ with $ W $ or the adversary in the real world generates anonymous keys for $ (m, \ring) $ more than the number of adversarial keys in $ \ring $.
				%				 
				
				%	\item If $ b = b_\simulator $, set $\mathtt{\hash}[m, W] = y $. Here, if $ \sigma $ is a signature of an honest party, $ \simulator $ sets its output with respect to the output selected by $ \fgvrf $. 
				%    Remark that we do not need to set $ \mathtt{H_p} $ because it already verifies in the real world.

			\item If $ b_\simulator = 0 $, it sets $ \pk = \perp $ and sends  $ (\oramsg{verified}, \allowbreak \sid, \allowbreak \ring, \allowbreak W, \allowbreak \aux, m, \sigma, b_\simulator, X) $ to $ \fgvrf $. Then, $ \simulator $ receives back $ (\oramsg{verified}, \allowbreak \sid, \allowbreak \ring, \allowbreak W, \aux,m, \sigma, \perp, 0) $. 
			%			\begin{itemize}
				%				\item If $ b \neq b_\simulator $, it means that it was a signature of an honest party and $ \NIZK.\Verify $ for $ \rcom $ does not validate in the real world. So, $ \simulator $ sets $\mathtt{\hash}[m, \ring,W] = y $ and $ \mathtt{H_p}[\ring, m, W, \compk, R', R_m'] = c $ where $ R' = s\genG + \delta K+ c\compk  $, $ R_m = s \hashG(m,\ring) + cW$. 
				%				Now, the signature verifies in the real world as well.
				%				\item If $ b = b_\simulator $, $ \simulator $ doesn't need to do anything.
				%			\end{itemize}
			
		\end{itemize}
		
		
		
		
		
		
	\end{itemize}
	
	We remark that \abort-2 happens in the oracle $ H_p $ described in Figure \ref{oracle:Hout} in the case where $ W $ is generated by $ \fgvrf $ for an honest party. The reason for this is that $ \fgvrf $ asks for $ \simulator $ to verify or not verify all signatures with  $ W $ that is not generated by $ \fgvrf $. $ \simulator $ runs $ \rVRF.\Verify $ for all such requests and replies accordingly. Therefore, the valid signatures for $ \msg, \aux' $ with malicious $ W $ (obtained via $ \oramsg{request\_signatures} $) must been already validated by $ \simulator $ before and $ \mathtt{H_p}[(\aux', \msg,\compk,W,R,R_m)] $ has been assigned with a random value. 
	
	We next show that the outputs of honest parties in the ideal world are indistinguishable from the honest parties running our first  ring VRF protocol.
	
	\begin{lemma}\label{lem:honestoutput}
		Assuming that the DDH problem is hard in $ \GG $, the outputs of honest parties in  our first ring VRF protocol are indistinguishable from the outputs of the honest parties in $ \fgvrf $ running $ \Gen_{sign} $  in Algorithm \ref{alg:gensign}.
	\end{lemma}

	\noindent \textit{Proof Outline.} 	The honest evaluation outputs generated by $ \fgvrf $ and generated by $ H $ in the real world protocol are distributed identically. The ring VRF signatures of honest parties in the ideal and real worlds ($ (\piring, \allowbreak \compk, \allowbreak \comring, \pieval, W) $ in $ \fgvrf $ and $ (\piring, \compk, \comring, \pieval, \PreOut) $ in $ \rVRF $) are in different distributions because $ W $ and $ \PreOut $ are generated differently. The rest is distributed identically. We can show that the two are indistinguishable under the assumption that the DDH problem is hard. The proof can be found in Appendix \ref{ap:ucproof}.
	
	
	Next we show that the simulation executed by $ \simulator $ against $ \adv $ is indistinguishable from the real protocol execution.
	
	\begin{lemma} \label{lem:simulation-ind}
		The view of $ \adv $ in its interaction with the simulator $ \simulator $ is indistinguishable from the view of $ \adv $ in its interaction with real honest parties assuming that CDH is hard in $ \GG $, $\hashG, \hash, \hash_p $ are random oracles, $ \NIZK_{\rcom}, \NIZK_{\rsnark}, \NARK_{\relcomring} $ are knowledge sound and $ \mathsf{Com} $ is computationally binding and perfectly hiding. 
	\end{lemma}

	\textit{Proof Outline.} The  simulation against the real-world adversary $ \adv $ is identical to the real protocol except the cases where $ \simulator $ aborts. \abort-1 does not occur, as explained above.  \abort-2 occurs if $ \Gen_{sign} $ generates the same $ \compk $ for two different signatures. This happens if $ \fgvrf $  selects the same $ \compk $ for two different honest signatures, which occurs with a negligible probability.
	Lastly, we consider the abort case (\abort-3) during the verification.
	For this, we show that if there exists an adversary $ \adv $ which makes $ \simulator $ abort during the simulation, then we can construct another adversary $ \bdv $ which breaks either the CDH problem or the binding property of $ \mathsf{Com}$. The proof can be found in Appendix \ref{ap:ucproof}.
	
	
	%This completes the security proof of our first  ring VRF protocol.
\end{proof}

