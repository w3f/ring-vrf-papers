% !TEX root = crypto.tex

\newcommand{\name}{rVRF}

\label{ap:ucproof}
\label{sec:ringvrfconstrnoPK}
\newcommand{\GG}{\grE}
\newcommand{\FF}{\F}
\newcommand{\hash}{H}
\newcommand{\hashG}{\hash_\grE}
\newcommand{\gen}{\mathsf{Gen}}
\newcommand{\hkeys}{\mathtt{honest\_keys}}
\newcommand{\malkeys}{\mathtt{malicious\_keys}}
\newcommand{\rcom}{\mathcal{R}_{eval}}
\newcommand{\rsnark}{\Rring}
\newcommand{\counter}{\mathsf{counter}}
\newcommand{\bdv}{\mathcal{B}}
\newcommand{\abort}{\textsc{Abort}}
\newcommand{\pkeys}{\arraysym{public\_keys}}
\newcommand{\skeys}{\arraysym{secret\_keys}}
\newcommand{\keytransform}{T_{\mathsf{key}}}
%Before giving the security proof of our protocol, we give the protocol in Section \ref{sec:pederson_vrf} without the abstraction from $ \PedVRF $ for the sake of  clarity of the security proof.
%
%We instantiate parameter generation by constructing a group $\GG$ of order $ p $ and two generators $ \genG, \genB \in  \GG$.  We consider three hash functions: $ \hash, \hash_p: \{0,1\}^* \rightarrow \FF_p $ and a hash-to-group function $\hashG : \{0,1\}^* \rightarrow \GG$ and . \name \ works as follows:
%
%\begin{itemize}
%	\item $ \rVRF.\KeyGen(1^\kappa):  $ It selects randomly a secret key $ x \in \FF_p$ and computes the public key $ X = xG $. In the end, it outputs $ \sk = x $ and $ \pk = X $.
%	
%	%It also generates  PoK for the discrete logarithm of $ X $ for the relation $ \R_{dl} $, $ \NIZK.\Prove(\rdl, (x, (X, G, \GG))) \rightarrow \pi_{dl} $.
%	
%	%\begin{equation}
%	%	\rdl = \{(x,(X,G,\GG)): X,G \in \GG, x \in \FF_p, x = xG\}
%	%\end{equation}
%	
%	%For this, it does the following: $ a \leftsample \FF_p $, $ c = \hash_p(a\genG, X) $, $ s = a + cx $. 
%	
%	%	\item $ \rVRF.\eval(\sk, \ring, m) $: It lets $ P = \hashG(m, \ring) $ and computes $ W = xP  $. Then, it outputs $ y = \hash(m, \ring, W) $. So, the deterministic function $ F $ in our rVRF protocol is $ F(\sk, \ring, m) = H(m, \ring, x\hashG(m,\ring)) $.
%	%	
%	\item $ \rVRF.\Sign(\sk, \ring, m):$ It lets $ \In = \hashG(m) $ and computes the pre-output $ \PreOut= x\In$. The signing algorithm works as follows: 
%
%	\begin{itemize}
	%		
	%		\item It first commits to its secret key $
	%		x$ i.e., $ \compk = X + \openpk \, \genB $ where $ \openpk \leftsample \FF_p $.
	%		\item It generates a Chaum-Pedersen DLEQ proof $ \pi_{eval} $ showing the following relation by running the algorithm $ \NIZK_{\rcom}.\Prove(((\genG, \genB,\GG,\compk,\PreOut,\In); (x, \openpk))) $ which outputs $ \rightarrow \pi_{eval}$
	%		\eprint{\begin{align}
			%				\rcom= \{((x, \openpk), (\genG, \genB,\GG,\compk,\PreOut,\In)): 
			%				\compk = x\genG + \openpk\, \genB, \PreOut = x \,\In \} \label{rel:commit} 
			%		\end{align}}{
		%		\begin{align}
			%			\rcom= \{((x, \openpk), (\genG, \genB,\GG,\compk,\PreOut,\In)): \\
			%			\compk = x\genG + \openpk\, \genB, \PreOut = x \,\In \} \label{rel:commit} \nonumber
			%		\end{align}}
	%		Here $ \Prove $ algorithm runs a non-interactive Chaum-Pedersen DLEQ proof with the Fiat-Shamir transform:  Sample random $r_1, r_2 \leftarrow \F_p$.
	%		Let $R = r_1 \genG + r_2 K$, $R_m = r_1 \In$, and
	%		$c = \hash_p(\ring, m, \PreOut,\compk,R,R_m)$.
	%		Set $\pi_{eval} = (c,s_1,s_2)$ where $s_1 = r_1 + c x$ and $s_2= r_2 + c \, \openpk$.
	%		\item %It obtains $ crs $ from $ \gcrs $ for the second proof by sending the message $ (\oramsg{learncrs}, \sid) $ to $ \gcrs $. Then,
	%		%It constructs a Merkle tree $ \mathsf{MT} $ with the nodes $ X_i $ where  $ X_i \in \pk_i $ and $ \pk_i \in  \ring $. We denote its  root by $ \mathsf{root} $. In the end, 
	%		It generates the second proof $ \pi_{ring} $ for the following relation with  the witness $ (\ring, x, \openpk) $. 		
	%		
	%		\eprint{\begin{equation}
			%				%\rsnark = \{((\mathsf{copath}, X, \openpk),(G,\genB\GG,\mathsf{root}, \compk)): C-\openpk K = X, \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) \rightarrow 1\} \label{rel:snark}
			%				\rsnark = \{(X, \openpk),(\genG,\genB,\GG,\ring, \compk)): \compk-\openpk \, \genB = X \in \ring\} \label{rel:snark}
			%			\end{equation}
		%		}{\begin{align}
			%			\rsnark = \{(X, \openpk),(\genG,\genB,\GG,\ring, \compk)): \\\compk-\openpk \, \genB = X \in \ring\} \label{rel:snark} \nonumber
			%		\end{align}
		%	}
	%		
	%		%Here, $ \mathsf{copath} $ is a copath of the Merkle tree $ \mathsf{MT} $. $ \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) $ is a verification algorithm of the Merkle tree which verifies whether $ X $ is the one of the leaves of $ \mathsf{MT} $ i.e., compute a root $ \mathsf{root}' $ with $ X $ and $ \mathsf{copath} $ and output 1 if $ \mathsf{root} = \mathsf{root}' $.
	%		
	%		The second proof $ \pi_{ring} $ is generated by running 
	%		$ \NIZK_{\rsnark}.\Prove(((\genG,\genB,\GG,\ring, \compk); (X, \openpk))) $ 
	%	\end{itemize}
%	In the end, $ \rVRF.\Sign $ outputs $\sigma = (\pi_{eval}, \pi_{ring}, \compk, \PreOut) $.
%	
%	\item $ \rVRF.\Verify(\ring,\PreOut, m, \sigma) $: Given $  \sigma = (\pi_{eval}, \pi_{ring},\compk)  $ and $ \ring, \PreOut $,
%	% it first runs $ \NIZK.\Verify(\rdl,(X_i,\genG,\GG), \pi_{dl_i}) $ for each $ \pk_i= (X_i, \pi_{dl_i})  \in \ring $. If each of key in $ \ring $ verifies,
%	it runs $ \NIZK_{\rcom}.\Verify((\genG, \genB,\GG,\compk,\PreOut,\In), \pi_{eval} ) $ where $ P = \hashG(m) $. $ \NIZK_{\rcom}.\Verify $ works as follows: $ \pi_{eval} = (c,s_1, s_2) $, it lets $R' = s_1 \genG + s_2 \, \genB - c \,\compk$ and $R'_m = s_1 \hashG(m) - c \, \PreOut$. It
%	returns true if $c = \hash_p(\ring,m,\PreOut,\compk,R',R'_m)$. If  $ \NIZK_{\rcom}.\Verify((\genG, \genB,\GG,\compk,\PreOut,\In), \pi_{eval} ) $ outputs 1, it runs $ \NIZK_{\rsnark}.\Verify((\genG,\genB,\GG,\ring, \compk), \pi_{ring}) $. 
%	If all verification algorithms verify, it outputs $ 1 $ and the evaluation value $ y =  \hash(m,\PreOut)  $. Otherwise, it outputs $( 0, \perp) $.
%	
%\end{itemize}
%
%\subsection{Security Analysis}

\subsection{Security Analysis of Our First Ring VRF Construction}
With $ \gen_{sign} $  for $ \fgvrf $ defined as above, we first show that  $ \gen_{sign} $ satisfies Definition \ref{def:anonymity} so that $ \fgvrf $ assures anonymity. 



%\begin{algorithm}
%	\caption{$\gen_{W}(\ring,\pk,m)$}
%	\label{alg:genW}	 	
%	\begin{algorithmic}[1]
	%		\State$ W \leftsample\GG $
	%		%		\State \textbf{get} $ X \in \pk $
	%		%		\If{$\mathtt{DB}[m, \ring] = \perp  $}		
	%		%		\State{$ a \leftsample \FF_p $}		
	%		%		\State{$\mathtt{DB}[m, \ring] := a$}
	%		%		\EndIf
	%		%		\State$ a \leftarrow \mathtt{DB}[m, \ring] $
	%		%		
	%		%		\State \textbf{return} $ aX $
	%		\State \textbf{return} $ W $
	%	\end{algorithmic}
%	
%\end{algorithm}

%\begin{algorithm}
%	
%	\caption{$\gen_{sign}(\ring,W,x,\pk,\aux,\msg)$}
%	\label{alg:gensign}	 	
%	\begin{algorithmic}[1]
	%		\State $ c,s_1, s_2 \leftsample \FF_p $
	%		\State $ \pi_{eval}  \leftarrow (c,s_1, s_2)$
	%		\State $ \openpk \leftsample \FF_p $
	%		\State $ \compk =  x \genG + \openpk \, K$
	%		%\State $ \pi_{eval} \leftarrow \NIZK.\mathsf{Simulate}(\rcom, (G, \genB,\GG,\compk,W,\In)) $
	%		%\State \textbf{send} $(\oramsg{learn\_\tau},\sid)  $ to $ \gcrs $
	%		%\State \textbf{receive} $(\oramsg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
	%		\State $ \comring, \openring \leftarrow \rVRF.\CommitRing(\ring, \pk) $
	%		\State $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\Prove(\comring, \compk\; \openpk, \openring, x) $ 
	%		\State\Return$ \sigma = (\pi_{eval},\pi_{ring},\compk,\comring,W) $
	%	\end{algorithmic}
%	
%\end{algorithm}


\begin{lemma} \label{lem:anonymity} $ \Gen_{sign}$ in Algorithm \ref{alg:gensign} satisfies the anonymity defined in Definition \ref{def:anonymity} assuming  $ \NIZK_{\rsnark} $ is zero-knowledge and the Pedersen commitment is perfectly hiding.
\end{lemma}

\begin{proof} Assume that $ \mathcal{D} $ wins the anonymity game for $ \Gen_{sign} $ with advantage $ \epsilon $.
We reduce the anonymity game to a game where we remove line \ref{rel:commit} and change line \ref{line:piring} of Algorithm \ref{alg:gensign} with $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\mathsf{Simulate}(\tw_{\Rring}, \pp_{\Rring},\comring, \compk) $ where $ \comring = \com^*(\ring) $.  Our new game is indistinguishable by the zero-knowledge property of $ \NIZK_{\rsnark} $.  Since, in the new game, proofs are generated without the keys and $ \compk $ is perfectly hiding,   $ \mathcal{D} $ wins the new game with probability $ \frac{1}{2} $. Thus, $ \epsilon $ is negligible.		
\end{proof}

%We next show that our first protocol  realizes $ \fgvrf $  in the random oracle model under the assumption of the hardness of the decisional Diffie Hellman (DDH).

%The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.

%\begin{definition}[$ n $-One-More Gap Diffie-Hellman (OM-GDH) problem]
%	Given   $ p $-order group $ \GG $ generated by $ G $, the challenges $ G, X = xG, P_1, P_2, \ldots, P_{n+1} $ and access to the DH oracle $ \mathsf{DH}(.,.,.) $ and the oracle $ \mathcal{O}_x(.) $ which returns $ x\In$ given input $ \In$, if a PPT adversary $ \mathcal{A} $ outputs $ xP_1, xP_2, \ldots, xP_{n+1} $ with the access of at most $ n $-times to the oracle $ \mathcal{O}_x $, then $ \mathcal{A}  $ solves the $ n $-OM-GDH problem. We say that $ n $-OM-GDH problem is hard in $ \GG $, if for all PPT adversaries, the probability of solving the $ n $-OM-GDH problem is negligible in terms of the security parameter.
%\end{definition}
We now state the security guarantees for our first construction when $ \pk $ is defined as $ \mathsf{Com}.\mathsf{Commit}(x,r) $ where $ \sk = (x, r) $ is the secret key (Alternative 1) and  when $ \pk $ is defined as $ \pk = \sk\genG $ where $ \sk = x $  (Alternative 2).
\liz{What are we doing with Alternative 2?}
\begin{theorem}\label{thm:firstprotocol}
	Our first ring VRF construction realizes $ \fgvrf $ running $ \Gen_{sign} $ in Algorithm \ref{alg:gensign} in the random oracle model assuming that $ \NIZK_{\mathcal{R}_{eval}} $ and $ \NIZK_{\mathcal{R}_{ring}}$ are zero-knowledge and knowledge sound, $ \NARK_{\relcomring} $ is knowledge sound, the decisional Diffie-Hellman (DDH) problem is hard in $ \grE  $ \eprint{(so the CDH problem is hard as well)}{and the commitment scheme $ \mathsf{Com} $ is computationally binding and perfectly hiding for Alternative 1}. 
\end{theorem}

The proof can be found in the full version of the paper, at this anonymous link~\cite{anonymous}.
\\\\
We present our definition and instantiations of a zk continution in Appendix~\ref{sec:rvrf_cont} and our second ring VRF construction in Appendix~\ref{subsec:rvrf_faster}.

